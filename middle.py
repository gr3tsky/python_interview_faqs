#1. Итераторы и генераторы yield. Как его создать? Чем отличается iterator от iterable?
# Итератор - это объект, который осуществляет доступ к элементам последовательности.
# Итерация - это процесс  (цикл) обработки элементов последовательности.Один шаг в цикле тоже называется итерацией.
# На каждой итерации итератор (с помощью своего метода __next__) указывает на следующий и возвращает текущий
# элемент (и удаляет его из очереди).
# Итерируемый объект включает в себя (помимо последовательности) итератор (для цикличесой обработки).
# Итераторы - это специальные объекты, предоставляющие последовательный доступ к данным из контейнера.

#######################################################################
#2. Магические методы
# контекстный менеджер (enter, exit), классы (new, init, del, getattr, setattr, str)

#######################################################################
#3. Что напечатает
import datetime as dt

def foo(time=dt.datetime.now()): # дефолтное значение datetime.now() присваивается в момент определения функции 
  print(time)
  
foo() # 2018-04-25 12:55:01.317672
foo() # 2018-04-25 12:55:01.317672
foo() # 2018-04-25 12:55:01.317672

#######################################################################
#4. Что напечатает
def foo(x, a=[]):
  a.append(x)
  print(a)

foo(2) # [2]
foo(3,[1, 2]) # [1, 2, 3]
foo(4) # [2, 4]

#######################################################################
#5. Что напечатается
def f(*args, **kwargs):
  print(args, kwargs)
  
f(*[1, 2, 3])
#([1, 2, 3], {})

#######################################################################
#6. Какой результат выполнения?
a = dict(one=1, two=2, three=3)
keys = a.keys()
a['four'] = 4
print(keys)
#['three', 'two', 'one']

#######################################################################
#7.В чем разница в выполнении?
d = dict(zip(range(50000000), range(50000000)))
keys1 = list(d)
keys2 = d.keys()
print(49999999 in keys1)
print(49999999 in keys2)
key3 = d
#True
#True

#######################################################################
#8. Для чего нужны global и nonlocal statements?

#######################################################################
#9. Для чего используется декоратор @funktools.wraps?
# Для копирования module, name, qualname, annotations docupdates the wrapper function's dict,
# чтобы эти параметры скопировать из функции в декорирующую алиас functools.update_wrapper()

#######################################################################
#10. Как в Python определить абстрактный метод?
from abc import ABC

class C(metaclass=ABC):
  pass

#######################################################################
#11. Как добавить bound метод в класс после его объявления, как добавить bound метод в инстанс класса?
#1) Использовать types.MethodType
import types

a.foo = types.MethodType(foo, a)
a.foo

#######################################################################
#12. Как получить у класса список атрибутов, методов?
# Все данные объекта хранятся в "__dict__"
class Record():
  pass

record = Record()
record.id = 10
record.link = "record/"

#######################################################################
#13. Для чего используется str и repr и какая между ними разница?
# repr(obj) возвращает однозначное текстовое представление (representation) объекта, полезное для отладки,
# сообщений об ошибках
# str(obj) возвращает читаемый текст. Для многих объектов имеет смысл определить __repr__()
# (так как реализация по умолчанию в object.__repr__ не слишком информативна).
# __str__() имеет смысл определять для объектов, для которых существует "естественное"
# человеко-читаемое (неспецифичное для Python) представление (как в примере с датой), например для логов.
class A:
  pass
#   def __str__(self):
#     return 'str'

#   def __repr__(self):
#     return 'repr'
g = A()
str(g)
repr(g)

#######################################################################
#14. Что делает оператор "whith".context managers?
# Менеджер контекста представляет собой объект, который создает контекст внутри оператора whith
# и обладает двумя методами _enter_ и _exit_. Менеджеры контекста позволяют выделятьи освобождать ресурсы
# строго по необходимости. Предположим у вас есть две связанные операции, которые вы хотите исполнить в паре,
# поместив между ними блок кода. Менеджеры контекста позволяют сделать именно это.

#######################################################################
#15. Что такое generator в Python? Как его создать?
def fib(number):
  a, b = 0, 1
  
  for _ in range(number):
    yield a
    a, b = b, a + b
    
print(list(fib(10)))
# [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]

#######################################################################
#16. Что делает функция type() ?
# type(name, bases, dict) - Возвращает новый экземпляр класса name.

#######################################################################
#17. Чем отличаются методы получения типа класса isinstance(obj) type(obj) и obj.__class__?

#######################################################################
#18. Что такое weakref?
#
#
#


























